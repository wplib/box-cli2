#!/usr/bin/env bash
#
# box - CLI for WPLib Box - https://github.com/wplib/wplib-box
# 
# Initialize vars
BOXCLI_INCLUDE_DIR=""
BOXCLI_CLAUSES=()

if [ "" == "${BOXCLI_RECURSION}" ]; then 
    export BOXCLI_RECURSION=0
fi 

#Find the ROOR_DIR for the BOX CLI source
if [ $(uname) = "Darwin" ] ; then
    #This only works on Mac OSX
    BOXCLI_ROOT_DIR=$(dirname $(readlink "$0"))
else
    #This works on Ubuntu if realpath has been installed
    BOXCLI_ROOT_DIR=$(dirname $(realpath "$0"))
fi



# Load BOXCLI_* functions and constants
source "${BOXCLI_ROOT_DIR}/inc/const.sh" "${BOXCLI_ROOT_DIR}"
mkdir -p "${BOXCLI_TEMP_DIR}"

source "${BOXCLI_ROOT_DIR}/inc/funcs.sh"
__boxProcessCmdLine "$@"

# Run reset script to ensure known bash environment
source "${BOXCLI_INCLUDE_DIR}/reset.sh"

# Grab 1st parameter as command, default to "help"
__command="${1:-}"
__args=()
__argNames=()
__argNum=0
__path="${BOXCLI_ROOT_DIR}"
if (( 0 < "${#BOXCLI_CLAUSES[@]}" )) ; then
    for clause in "${BOXCLI_CLAUSES[@]}" ; do
        __testdir="${__path}/cmd"
        if ! [ -d "${__testdir}" ] ; then
            # If we don't have a command but we have an args
            __testdir="${__path}/args"
            if ! [ -d "${__testdir}" ] ; then
                stdErr "Arguments not allowed."
                break
            elif (( 0 == "${#__args[@]}" )) ; then
                for arg in $__testdir/* ; do
                    # example $arg: (A) "/.../3-abc=123" or (B) "/.../2-xyz"
                    __argName=$(basename "${arg}")
                    __order="${__argName:0:1}"
                    __argName="${__argName:2}"
                    __value="${__argName#*=}"   # Get after "="
                    __name="${__argName%=*}"    # Get upto "="
                    [ "${__argName}" = "${__name}" ] && __value=""  # clear out default if (B).
                    __args+=($__value)
                    __argNames+=($__name)
                done
            fi
            __args[$__argNum]="${clause}"
            __argNum=$((__argNum+1))
            if (( __argNum > "${#__args[@]}" )) ; then
                stdErr "Too many arguments."
                break
            fi
            continue
        fi
        __filepath=""
        __testdir="${__path}/cmd/${clause}"
        if [ -d "${__testdir}" ] ; then
            __path="${__testdir}"
            __filepath="${__testdir}/${clause}.sh"
            shift # remove command name from "$@"
            continue
        fi
        for alias in $__path/cmd/* ; do
           __testdir="${alias}/alias/${clause}"
            if [ -f "${__testdir}" ] ; then
                segment=$(basename "${alias}")
                __path="${__path}/cmd/${segment}"
                __filepath="${__path}/cmd/${segment}/${segment}.sh"
                __valid=1
                shift # remove command name from "$@"
                break
            fi
        done
    done

    if [ -z "${__filepath}" ] ; then
        IFS=' '
        stdErr "'$*' not a valid box command."
        exit
    fi

    #printf '%s\n' "${__argNames[@]}"
    #printf '%s\n' "${__args[@]}"

    BOXCLI_PATH="${__path}"
    BOXCLI_SCRIPT="${__filepath}"
    BOXCLI_ARGCOUNT=("${#__args[@]}")

    if (( 0 == "${#__args[@]}" )) ; then
        BOXCLI_ARGS=()
    else
        BOXCLI_ARGS=("${__args[@]}")
    fi

    ((BOXCLI_RECURSION++))
    if (( 0 == "${#__argNames[@]}" )) ; then
        BOXCLI_ARGNAMES=()
        source "${__filepath}"
    else
        BOXCLI_ARGNAMES=("${__argNames[@]}")
        source "${__filepath}" "$@"
    fi
    ((BOXCLI_RECURSION--))
    if (( 0 == $BOXCLI_RECURSION )) ; then
        stdOut "Done."
    fi

    unset BOXCLI_RECURSION

fi
